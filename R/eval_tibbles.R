#' Workhorse for simulation studies
#'
#'  Generates data according to all provided 
#'  constellations in \code{data_tibble} and applies
#'  all provided constellations in \code{proc_tibble}
#'  to them.
#'
#'
#'@param dataGrid  a \code{data.frame} where the first column
#'  is a character vector with function names. The other
#'  columns contain parameters for the functions specified
#'  in the first column. Parameters with NA are ignored.
#'@param procGrid  similar as \code{dataGrid} the first
#'  column must contain function names. The other columns 
#'  contain parameters for the functions specified in the
#'  first column. The data generated according to 
#'  \code{dataGrid} will always be passed to the first
#'  unspecified argument of the functions sepcified in the first 
#'  column of \code{procGrid}.
#'@param replications  number of replications for the simulation
#'@param discardGeneratedData  if \code{TRUE} the generated 
#'  data is deleted after all function constellations in 
#'  \code{procGrid} have been applied. Otherwise, ALL
#'  generated data sets will be part of the returned object.
#'@param summary_fun  named list of univariate function to summarize the results (numeric or logical) over
#'  the replications, e.g. list(mean = mean, sd = sd). 
#'@param ncpus  a cluster of \code{ncpus} workers (R-processes)
#'  is created on the local machine to conduct the
#'  simulation. If \code{ncpus}
#'  equals one no cluster is created and the simulation
#'  is conducted by the current R-process.
#'@param cluster  a cluster generated by the \code{parallel}
#'  package that will be used to conduct the simulation.
#'  If \code{cluster} is specified, then \code{ncpus} will
#'  be ignored.
#'@param clusterSeed  if the simulation is done in parallel
#'  manner, then the combined multiple-recursive generator from L'Ecuyer (1999) 
#'  is used to generate random numbers. Thus \code{clusterSeed} must be a (signed) integer 
#'  vector of length 6. The 6 elements of the seed are internally regarded as 
#'  32-bit unsigned integers. Neither the first three nor the last three 
#'  should be all zero, and they are limited to less than 4294967087 and 
#'  4294944443 respectively.
#'@param clusterLibraries  a character vector specifying
#'  the packages that should be loaded by the workers.
#'@param clusterGlobalObjects  a character vector specifying
#'  the names of R objects in the global environment that should
#'  be exported to the global environment of every worker.
#'@param envir  must be provided if the functions specified
#'  in \code{dataGrid} or \code{procGrid} are not part
#'  of the global environment.
#'@return  The returned object list of the class
#'  \code{eval_tibbles}, where the element \code{simulations} contain
#'  the results of the simulation.
#'@note  If \code{cluster} is provided by the user the
#'  function \code{eval_tibbles} will NOT stop the cluster.
#'  This has to be done by the user. Conducting parallel
#'  simulations by specifing \code{ncpus} will interally
#'  create a cluster and stop it after the simulation
#'  is done.
#'@author  Marsel Scheer
#'@seealso  \code{\link{as.data.frame.evalGrid}}
#'@export
eval_tibbles <-
  function(dataGrid, procGrid=expandGrid(proc="length"), replications = 1, 
           discardGeneratedData=FALSE, post_analyze = identity, 
           summary_fun=NULL, 
           ncpus = 1L, cluster=NULL, clusterSeed=rep(12345,6),
           clusterLibraries=NULL,
           clusterGlobalObjects=NULL,           
           envir=globalenv()) {
    
    mc = match.call()

    summary_fun = prepare_summary_fun(summary_fun)
    df = data_grid_to_fun(dataGrid, envir)
    pf = proc_grid_to_fun(procGrid, envir)
    cluster = prepare_cluster(cluster, ncpus, clusterGlobalObjects, clusterLibraries, clusterSeed, df, pf)
    sim_fun = define_simulation(pf, discardGeneratedData, cluster, replications, summary_fun, post_analyze)

    pb = progress_bar(df)
    
    t1 = Sys.time()

    tryCatch(
      {
        simulation_list = lapply(df, function(fc) 
        {
          ret = sim_fun(fc)
          pb()
          ret
        })  
        t2 = Sys.time()
      }, 
      finally =
      {
        if (ncpus > 1)
          parallel::stopCluster(cluster)
      }
    )
    
    
    est.reps.per.hour = as.integer(replications/as.numeric(difftime(t2, t1, units="hour")))
    
    print(paste("Estimated replications per hour: ", est.reps.per.hour))
    ret <- list(call = mc, dataGrid = dataGrid, procGrid = procGrid, 
               simulation = frame_simulation(dataGrid, procGrid, simulation_list, summary_fun), 
               summary_fun = summary_fun,
               est.reps.per.hour = est.reps.per.hour,
               sessionInfo = sessionInfo())
    class(ret) <- "eval_tibbles"
    ret
  }

# ###############################################
# rng = function(data, ...) {
#   ret = range(data)
#   names(ret) = c("min", "max")
#   ret
# }
# 
# dg <- expandGrid(fun = "seq_len", length.out = 1:3)
# pg <- expandGrid(proc = c("rng", "median", "length"))
# #debugonce(eval_tibbles)
# eg <- eval_tibbles(dg, pg,rep = 2000)#, summary.fun = (mean, sd))
# microbenchmark::microbenchmark(
#   old = evalGrids(dg, pg,rep = 2000),
#   new = eval_tibbles(dg, pg,rep = 2000),
#   times = 10
# )
# #####################################################
# regData = function(n, SD){
#   data.frame(
#     x=seq(0,1,length=n),
#     y=rnorm(n, sd=SD))
# }
# 
# microbenchmark::microbenchmark(
#   old = evalGrids(
#     expandGrid(fun="regData", n=20, SD=1:2),
#     expandGrid(proc="lm", formula=c("y~x", "y~I(x^2)")),
#     replications=200
#   ),
#   new = eval_tibbles(
#     expandGrid(fun="regData", n=20, SD=1:2),
#     expandGrid(proc="lm", formula=c("y~x", "y~I(x^2)")),
#     replications=200
#   ),
#   times = 10
# )
# #####################################################